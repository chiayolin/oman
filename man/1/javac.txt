javac(1)							      javac(1)



NAME
       javac - Java compiler

SYNOPSIS
       javac [ options ] [ sourcefiles ] [ @argfiles ]

PARAMETERS
       Arguments may be in any order.

       options	      Command line options.

       sourcefiles    One  or  more  source  files  to	be  compiled  (such as
		      MyClass.java).

       @argfiles      One or more  files  that	list  source  files.   The  -J
		      options are not allowed in these files.

DESCRIPTION
       The  javac  tool  reads class and interface definitions, written in the
       Java programming language, and compiles them into bytecode class files.

       There are two ways to pass source code file names to javac:

       o For a small number of source files, simply list the file names on the
	 command line.

       o For a large number of source files, list the file names  in  a  file,
	 separated  by	blanks	or line breaks. Then use the list file name on
	 the javac command line, preceded by an @ character.

       Source code file names must have .java suffixes, class file names  must
       have  .class  suffixes,	and both source and class files must have root
       names that identify the class.  For example,  a	class  called  MyClass
       would be written in a source file called MyClass.java and compiled into
       a bytecode class file called MyClass.class.

       Inner class definitions produce additional class  files.   These  class
       files  have  names  combining  the inner and outer class names, such as
       MyClass$MyInnerClass.class.

       You should arrange source files in a directory tree that reflects their
       package	tree.	For  example,  if  you	keep  all your source files in
       /workspace, the source code for com.mysoft.mypack.MyClass should be  in
       /workspace/com/mysoft/mypack/MyClass.java.

       By  default, the compiler puts each class file in the same directory as
       its source file.  You can specify a separate destination directory with
       -d (see OPTIONS, below).

   Searching for Types
       When  compiling	a  source  file,  the compiler often needs information
       about a type whose definition did not appear in the source files  given
       on  the	command  line.	 The compiler needs type information for every
       class or interface used, extended, or implemented in the  source  file.
       This  includes  classes	and interfaces not explicitly mentioned in the
       source file but which provide information through inheritance.

       For example, when you subclass java.applet.Applet, you are  also  using
       Applet's    ancestor   classes:	 java.awt.Panel,   java.awt.Container,
       java.awt.Component, and java.awt.Object.

       When the compiler needs type information, it looks for a source file or
       class  file which defines the type.  The compiler searches first in the
       bootstrap and extension classes, then in the user class path (which  by
       default	is  the current directory).  The user class path is defined by
       setting the CLASSPATH environment variable or by using  the  -classpath
       command line option.  (For details, see Setting the Class Path.)

       If  you use the -sourcepath option, the compiler searches the indicated
       path for source files; otherwise the compiler searches the  user  class
       path  both for class files and source files.  You can specify different
       bootstrap or extension classes with  the  -bootclasspath  and  -extdirs
       options; see Cross-Compilation Options below.

       A  successful  type  search may produce a class file, a source file, or
       both.  Here is how javac handles each situation:

       o Search produces a class file but no source file: javac uses the class
	 file.

       o Search  produces  a source file but no class file: javac compiles the
	 source file and uses the resulting class file.

       o Search produces both a source file and a class file: javac determines
	 whether  the  class file is out of date.  If the class file is out of
	 date, javac recompiles the source file and  uses  the	updated  class
	 file.	Otherwise, javac just uses the class file.

	 By  default,  javac  considers a class file out of date only if it is
	 older than the source file.

       Note: javac can silently compile source files not mentioned on the com-
       mand line.  Use the -verbose option to trace automatic compilation.

OPTIONS
       The  compiler  has  a set of standard options that are supported on the
       current	development  environment  and  will  be  supported  in	future
       releases.   An  additional  set of non-standard options are specific to
       the current virtual machine implementation and are subject to change in
       the future.  Non-standard options begin with -X.

   Standard Options
       -classpath classpath
	      Sets  the user class path, overriding the user class path in the
	      CLASSPATH environment variable.  If neither CLASSPATH or -class-
	      path  is	specified, the user class path consists of the current
	      directory.  See Setting the Class Path for more details.

	      If the -sourcepath option is not specified, the user class  path
	      is searched for both source files and class files.

       -Djava.ext.dirs=directories
	      Override the location of installed extensions.

       -Djava.endorsed.dirs=directories
	      Override the location of endorsed standards path.

       -d directory
	      Sets the destination directory for class files.  The destination
	      directory must already exist; javac will not create the destina-
	      tion directory.  If a class is part of a package, javac puts the
	      class file in a subdirectory reflecting the package name, creat-
	      ing  directories	as  needed.   For  example,  if you specify -d
	      /home/myclasses and the class is	called	com.mypackage.MyClass,
	      then   the  class  file  is  called  /home/myclasses/com/mypack-
	      age/MyClass.class.

	      If -d is not specified, javac puts the class file  in  the  same
	      directory as the source file.

	      Note:  The  directory specified by -d is not automatically added
	      to your user class path.

       -deprecation
	      Shows a description of each use or override of a deprecated mem-
	      ber  or  class.	Without -deprecation, javac shows the names of
	      source files that use or override deprecated members or classes.
	      -deprecation is shorthand for -Xlint:deprecation.

       -encoding encoding
	      Sets    the    source    file    encoding    name,    such    as
	      EUCJIS/SJIS/ISO8859-1/UTF8.  If -encoding is not specified,  the
	      platform default converter is used.

       -g     Generates  all debugging information, including local variables.
	      By default, only line number and source file information is gen-
	      erated.

       -g:none
	      Does not generate any debugging information.

       -g:keyword-list
	      Generates only some kinds of debugging information, specified by
	      a comma separated list of keywords. Valid keywords are:

	      source	Source file debugging information

	      lines	Line number debugging information

	      vars	Local variable debugging information

       -help  Prints a synopsis of standard options.

       -nowarn
	      Disables	warning  messages.  This  has  the  same  meaning   as
	      -Xlint:none.

       -source release
	      Enables support for compiling source code containing assertions.
	      The following values for release are allowed:

		 1.5  The compiler accepts code containing generics and  other
		      language	features  introduced  in JDK 1.5. The compiler
		      defaults to the 1.5 behavior if the -source flag is  not
		      used.

		 5    Synonym for 1.5

		 1.4  The  compiler  accepts code containing assertions, which
		      were introduced in JDK 1.4.

		 1.3  The compiler does not support assertions,  generics,  or
		      other language features introduced after JDK 1.3.

       -sourcepath sourcepath
	      Specify  the  source  code path to search for class or interface
	      definitions.  As with the user class path, source  path  entries
	      are  separated  by  colons  (:)  and can be directories, JAR ar-
	      chives, or ZIP archives.	If packages are used, the  local  path
	      name  within  the  directory or archive must reflect the package
	      name.

	      Note: Classes found through the classpath are subject  to  auto-
	      matic recompilation if their sources are found.

       -verbose
	      Verbose  output.	 This  includes  information  about each class
	      loaded and each source file compiled.

       -X     Display information about non-standard options and exit.

   Cross-Compilation Options
       By default, classes are compiled against the  bootstrap	and  extension
       classes	of  the  JDK  that javac shipped with. But javac also supports
       cross-compiling, where classes are compiled  against  a	bootstrap  and
       extension  classes  of a different Java platform implementation.  It is
       important to use -bootclasspath and -extdirs when cross-compiling;  see
       Cross-Compilation Example below.

       -target version
	      Generates  class	files that will work on VMs with the specified
	      version.	The default is to generate class files to be  compati-
	      ble  with  1.2  VMs,  with  one  exception. When the -source 1.4
	      option is used, the default target is 1.4.   The	versions  sup-
	      ported by javac are:

	      1.1    Ensures  that  generated  class  files will be compatible
		     with 1.1 and later.  VMs.

	      1.2    Generates class files that will run on 1.2 and later VMs,
		     but will not run on 1.1 VMs.

	      1.3    Generates	class files that run on VMs in the Java 2 SDK,
		     v1.3 and later, but will not run on 1.1 or 1.2 VMs.

	      1.4    Generates class files that will run on VMs in JDK 1.4 and
		     later, but will not run on 1.1, 1.2, or 1.3 VMs.

	      1.5    Generate  class  files  that are compatible only with JDK
		     1.5 VMs.

	      5      Synonym for 1.5

       -bootclasspath bootclasspath
	      Cross-compiles against the specified set of  boot  classes.   As
	      with  the user class path, boot class path entries are separated
	      by colons (:) and can be directories, JAR archives, or  ZIP  ar-
	      chives.

       -cldc1.0
	      Use  to compile CLDC programs. The compiler generates stack maps
	      making the use of the preverifier unnecessary.

       -extdirs directories
	      Cross-compiles  against  the  specified  extension  directories.
	      directories are a colon-separated list of directories.  Each JAR
	      archive in the  specified  directories  is  searched  for  class
	      files.

   Non-Standard Options
       -Xbootclasspath/p:path
	      Prepend to the bootstrap class path.

       --Xbootclasspath/a:path
	      Append to the bootstrap class path.

       -Xbootclasspath/:path
	      Override location of bootstrap class files.

       -Xlint Enable  all recommended warnings. In this release, all available
	      warnings are recommended.

       -Xlint:none
	      Disable all warnings not mandated by the Java Language  Specifi-
	      cation.

       -Xlint:-xxx
	      Disable  warning xxx, where xxx is one of the warning names sup-
	      ported for -Xlint:xxx, below.

       -Xlint:unchecked
	      Give more detail for unchecked conversion warnings that are man-
	      dated by the Java Language Specification.

       -Xlint:path
	      Warn  about nonexistent path (classpath, sourcepath, etc) direc-
	      tories.

       -Xlint:serial
	      Warn about missing serialVersionUID definitions on  serializable
	      classes.

       -Xlint:finally
	      Warn about finally clauses that cannot complete normally.

       -Xlint:fallthrough
	      Check switch blocks for fall-through cases and provide a warning
	      message for any that are found. Fall-through cases are cases  in
	      a  switch  block,  other	than the last case in the block, whose
	      code does not include a break statement, allowing code execution
	      to  "fall through" from that case to the next case. For example,
	      the code following the case 1 label in this  switch  block  does
	      not contain a break statement:

	      switch (x) {
	      case 1:
		      System.out.println("1");
		      //  No  break;  statement here.
	      case 2:
		      System.out.println("2");
	      }

       If  the -Xlint:fallthrough flag were used when compiling this code, the
       compiler would emit a warning about "possible fall-through into	case,"
       along with the line number of the case in question.

       -Xmaxerrors number
	      Set the maximum number of errors to print.

       -Xmaxwarns number
	      Set the maximum number of warnings to print.

       -Xstdout filename
	      Send  compiler messages to the named file.  By default, compiler
	      messages go to System.err.

THE -J OPTION
       -Joption
	      Pass option to the java launcher called by javac.  For  example,
	      -J-Xms48m  sets  the startup memory to 48 megabytes. Although it
	      does not begin with -X, it is not a `standard option' of	javac.
	      It is a common convention for -J to pass options to the underly-
	      ing VM executing applications written in Java.

       Note: CLASSPATH, -classpath, -bootclasspath, and -extdirs do not  spec-
       ify  the classes used to run javac. Fiddling with the implementation of
       the compiler in this way is usually pointless and always risky. If  you
       do  need  to  do this, use the -J option to pass through options to the
       underlying java launcher.

COMMAND LINE ARGUMENT FILES
       To shorten or simplify the javac command line, you can specify  one  or
       more files that themselves contain arguments to the javac command. This
       enables you to create javac commands of any  length  on	any  operating
       system.

       An  argument file can include javac options and source filenames in any
       combination.  The arguments within a file  can  be  space-separated  or
       newline-separated.   Filenames  within an argument file are relative to
       the current directory, not the location of the  argument  file.	 Wild-
       cards  (*)  are	not  allowed  in  these  lists (such as for specifying
       *.java).  Use of the @ character to recursively interpret files is  not
       supported.

       When  executing	javac, pass in the path and name of each argument file
       with the @ leading character.  When javac encounters an argument begin-
       ning  with  the	character @, it expands the contents of that file into
       the argument list.

   Example - Single Arg File
       You could use a single argument file named argfile to  hold  all  javac
       arguments:

		% javac @argfile

       This  argument  file  could contain the contents of both files shown in
       the next example.

   Example - Two Arg Files
       You can create two argument files -- one for the javac options and  the
       other  for  the	source	filenames: (Notice the following lists have no
       line-continuation characters.)

       Create a file named options containing:

	      -d classes
	      -g
	      -sourcepath /java/pubs/ws/1.3/src/share/classes

       Create a file named classes containing:

	      MyClass1.java
	      MyClass2.java
	      MyClass3.java

       You would then run javac with:

	      % javac @options @classes

   Example - Arg Files with Paths
       The argument files can have paths, but any filenames inside  the  files
       are relative to the current working directory (not path1 or path2):

	      % javac @path1/options @path2/classes

EXAMPLES
   Compiling a Simple Program
       One  source  file,  Hello.java, defines a class called greetings.Hello.
       The greetings directory is the package directory both  for  the	source
       file  and the class file and is off the current directory.  This allows
       us to use the default user class path. It also makes it unnecessary  to
       specify a separate destination directory with -d.

	  % ls
	     greetings/
	  % ls greetings
	     Hello.java
	  % cat greetings/Hello.java
	     package greetings;

	     public class Hello {
		  public static void main(String[] args) {
		     for (int i=0; i < args.length; i++) {
			 System.out.println("Hello " + args[i]);
		     }
		  }
	     }
	  % javac greetings/Hello.java
	  % ls greetings
	     Hello.class   Hello.java
	  % java greetings.Hello World Universe Everyone
	     Hello World
	     Hello Universe
	     Hello Everyone

   Compiling Multiple Source Files
       This example compiles all the source files in the package greetings.

	  % ls
	     greetings/
	  % ls greetings
	     Aloha.java     GutenTag.java     Hello.java      Hi.java
	  % javac greetings/*.java
	  % ls greetings
	     Aloha.class    GutenTag.class    Hello.class     Hi.class
	     Aloha.java     GutenTag.java     Hello.java      Hi.java

   Specifying a User Class Path
       Having  changed	one  of  the  source files in the previous example, we
       recompile it:

	  % pwd
	     /examples
	  % javac greetings/Hi.java

       Since the class greetings.Hi refers to other classes in	the  greetings
       package,  the  compiler needs to find these other classes.  The example
       above works, because our default user class  path  happens  to  be  the
       directory  containing  the  package  directory.	But suppose we want to
       recompile this file and not worry about which directory we're in?  Then
       we  need  to  add  /examples to the user class path.  We can do this by
       setting CLASSPATH, but here we'll use the -classpath option.

	  % javac -classpath /examples /examples/greetings/Hi.java

       If we change greetings.Hi again, to use a banner utility, that  utility
       also needs to be accessible through the user class path.

	  % javac -classpath /examples:/lib/Banners.jar /examples/greetings/Hi.java

       To  execute  a class in greetings, we need access both to greetings and
       to the classes it uses.

	  % java -classpath /examples:/lib/Banners.jar greetings.Hi

   Separating Source Files and Class Files
       It often makes sense to keep source files and class files  in  separate
       directories,  especially  on large projects.  We use -d to indicate the
       separate class file destination.  Since the source files are not in the
       user class path, we use -sourcepath to help the compiler find them.

	  % ls
	     classes/  lib/	 src/
	  % ls src
	     farewells/
	  % ls src/farewells
	     Base.java	    GoodBye.java
	  % ls lib
	     Banners.jar
	  % ls classes
	  % javac -sourcepath src -classpath classes:lib/Banners.jar \
	     src/farewells/GoodBye.java -d classes
	  % ls classes
	     farewells/
	  % ls classes/farewells
	     Base.class      GoodBye.class

       Note:  The  compiler  compiled  src/farewells/Base.java, even though we
       didn't specify it on the command line.  To  trace  automatic  compiles,
       use the -verbose option.

   Cross-Compilation Example
       Here we use javac to compile code that will run on a 1.4 VM.

	  % javac -target 1.4 -bootclasspath jdk1.4.2/lib/classes.zip \
	       -extdirs "" OldCode.java

       The  -target  1.4 option ensures that the generated class files will be
       compatible with 1.4 VMs.  BY default, javac compiles for 1.5.

       The Java 2 SDk's javac would also by default compile  against  its  own
       bootstrap  classes, so we need to tell javac to compile against JDK 1.4
       bootstrap  classes  instead.   We  do  this  with  -bootclasspath   and
       -extdirs.   Failing to do this might allow compilation against a Java 2
       Platform API that would not be present on a 1.4 VM and  would  fail  at
       runtime.

SEE ALSO
       jar(1), java(1), javadoc(1), javah(1), javap(1), jdb(1)

       See or search the Java web site for the following:

       The Java Extensions Mechanism @
		 http://java.sun.com/j2se/1.5/docs/guide/extensions/index.html




				 05 March 2002			      javac(1)
